---
layout: default
title: articles/factorisation
category: pages
---

Integer factorisation isn't something I was particularly aware of until someone asked me for advice on how to factor a 174-digits number (which I'm guessing was as part of an RSA-type challenge).

A quick bit of research led me to a number of tools like `yafu` or `gmp-ecm`. This is all well and good, but I was curious as to how it is being done.

Note that in the below, we don't really care about finding *all* (prime) factors. As soon as we find one, it can reduce the difficulty considerably. We just assume our numbers are odd.

### Naive approach

Let's start small and simple. The function below takes the ceiling of the square root of the integer we want to factorise. At least one of the factors has to be less than that. We then decrement by 2 since we know there will be no even factor.

{% highlight python %}
    # 10 digits factors
    p1=4093082899
    p2=5463458053
    
    # 20 digits number
    c=p1*p2
    
    import math
    
    def dumb(c):
      starting_point = math.ceil(math.sqrt(c))
      for i in range(starting_point, 3, -1):
        if c % i == 0:
          print('found factor {0}'.format(i))
          return i
{% endhighlight %}

This snippet will find the smaller of the two factors (`p1`) in roughly 130s on my machine (a VM running on an i5).

Whilst this might sound reasonable, this only was a 20-digit number. Let's see if we can do better.

### Stepping it up a notch

Standing on the shoulders of giants, we will be implementing [Fermat's factorisation method](https://en.wikipedia.org/wiki/Fermat%27s_factorization_method).

{% highlight python %}
    # Newton's method
    def isqrt(n):
        x = n
        y = (x + 1) // 2
        while y < x:
            x = y
            y = (x + n // x) // 2
        return x
    
    def fermat1(c):
      a = math.ceil(math.sqrt(c))
      b2 = a*a - c
      v = isqrt(b2)
      while v*v != b2:
        a = a + 1
        b2 = a*a - c
        v = isqrt(b2) 
    
      ret = a - math.sqrt(b2)
      print('found factor {0}'.format(ret))
      return ret
{% endhighlight %}

`isqrt` gives us the integer square root.

Now for small numbers (e.g. `p1=8877691` and `p2=7833887`) this works just fine. But for the `p1` and `p2` defined above it took longer than I cared for. I stopped after 39,000,000 iterations. What gives?

When starting up, `a=4728888531` - which is roughly in the middle of the two factors. So the further those are apart, the longer it will take. But it shouldn't take *that* long.

It turns out the culprit is `isqrt`. This function is fine by itself but way too slow when used in anger. The easiest solution is to use the `gmpy2` module - a drop-in replacement that has a much faster implementation. How much faster? Well this implementation found the lower factor in 22 seconds!

{% highlight python %}
    def fermat2(c):
      a = math.ceil(math.sqrt(c))
      b2 = a*a - c
      v = gmpy2.isqrt(b2)
      while v*v != b2:
        a = a + 1
        b2 = a*a - c
        v = gmpy2.isqrt(b2) 
    
      ret = a - math.sqrt(b2)
      print('found factor {0}'.format(ret))
      return ret
{% endhighlight %}

(Note that `gmpy2` also has a `square` method, but in this particular case it was slower than the built-in `*`.)

Can we reduce that further?

### Quadratic Sieve

Whereas the above was quite straight forward, this is something else entirely. We are primarily focussing on the set of algorithms in [this paper](http://www.ams.org/notices/199612/pomerance.pdf), starting with Kraitchik's method.

A word of caution - the implementation is likely to be sub-optimal. But it should at least help us understand the what goes on behind the scenes.

#### Step 1

This is very similar to Fermat's method - we just generate numbers via the function $Q(x) = x^2 -n$.

{% highlight python %}
    def q_x(x, n):
      return x**2 - n
{% endhighlight %}

#### Step 2

We're looking for numbers generated by $Q(x)$ which can be factored by a common set of primes. For now we will derive our own factor base instead of decomposing every $Q(x)$ into its prime factors (which arguably might take longer). Which primes are suitable though - will any do? Not exactly. As per Brillhart and Morrison in the paper, we "discard those primes $p_j$ for which n is not congruent to a square, since such primes will never divide a number $Q_i$ in the continued fraction method nor a number $Q(x)$ in Kraitchikâ€™s method."

Okay so that's a bit of a mouthful. Thankfully this statement can be simplified to finding primes $p$ such that $(n/p)$ (the [Jacobi symbol](https://en.wikipedia.org/wiki/Jacobi_symbol)) is 1. The `gmpy2` module has that built in.

{% highlight python %}
{% endhighlight %}

Note that we only want the first $B$ primes. The larger $B$ is the more likely it is for the factors of $Q(x)$ to all be part of our factor base (hence we need to generate less $Q(x)$) - but there are other constraints to consider. We're starting small for now.

#### Step 3

Now that we have a factor base of size $B$, we want to generate $Q(x)$'s until we find $B+1$ of them that can be factored using that base.

{% highlight python %}
{% endhighlight %}
