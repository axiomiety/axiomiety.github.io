---
layout: post
title: chip8-part7
excerpt: "Writing a CHIP8 interpreter in C - debugging, ironing out bugs (wip)"
categories: [coding]
tags: [howto]
---

So it'd be great to say we're done - but there are still a couple of things to iron out.

# Test ROM

The [test ROM](https://github.com/corax89/chip8-test-rom) by `corax89` is really handy - when run it will validate instructions and assuming you have the `disp` instruction working (`0xdxyn`) it will output one of `ok` or `no` for each instruction type.

I took it for a spin and was greeted by 3 things. The first was that it completed before I could make any sense of what happened - so I added a `SDL_Delay(200);` after each iteration to slow things down (told you that timing thing would come back to haunt us...). The second was that every status code is displayed in the middle of the screen instead of in a grid format (woops). The third was a bunch of `no` statuses for my "set register to register" and subtraction operations:

![display](../../img/chip8/chip8_debugging-1.png)

A quick glance at the code showed that I had swapped registers `x` and `y` around:

```
diff --git a/src/mylib.c b/src/mylib.c
index 8901755..0740405 100644
--- a/src/mylib.c
+++ b/src/mylib.c
@@ -102,7 +102,7 @@ void jumpIfRegNotEqualToReg(State *state, uint8_t reg1, uint8_t reg2)
 }
 void setRegisterToRegister(State *state, uint8_t reg1, uint8_t reg2)
 {
-    state->registers[reg2] = state->registers[reg1];
+    state->registers[reg1] = state->registers[reg2];
     state->pc += 2;
 }
 void setRegisterToBitwiseOr(State *state, uint8_t reg1, uint8_t reg2)
```

For subtraction I messed up the `mod 255` operation:
```
@@ -143,15 +143,14 @@ void addRegisters(State *state, uint8_t reg1, uint8_t reg2)
 void subtractRegisters(State *state, uint8_t reg1, uint8_t reg2)
 {
     bool needBorrow = state->registers[reg2] > state->registers[reg1];
-    state->registers[reg1] = (state->registers[reg1] - state->registers[reg2]) + (needBorrow ? 0xff : 0);
-    // if we need a borrow, this is set  0
+    state->registers[reg1] = (state->registers[reg1] - state->registers[reg2]) % 0xff;
     state->registers[0xf] = needBorrow ? 0 : 1;
     state->pc += 2;
 }
 void subtractRightFromLeft(State *state, uint8_t reg1, uint8_t reg2)
 {
     bool needBorrow = state->registers[reg1] > state->registers[reg2];
-    state->registers[reg1] = (state->registers[reg2] - state->registers[reg1]) + (needBorrow ? 0xff : 0);
+    state->registers[reg1] = (state->registers[reg2] - state->registers[reg1]) % 0xff;
     // if we need a borrow, this is set  0
     state->registers[0xf] = needBorrow ? 0 : 1;
     state->pc += 2;
```

Fixing those and running the test ROM again gave me the all clear. But I couldn't readily tell what was wrong with the display.

# Fixing the display

## Controlling execution

One thing that I wanted was the ability to suspend execution - to be able to log some of the state (e.g. dump the registers, show the memory, ...), and resume/step through instructions. So I changed the main loop to this such that pressing space would suspend/resume execution, and pressing return would step through the next instruction (before suspending again).

{% highlight c %}
    bool running = true;
    bool step = false;
    while (!state.quit)
    {
        if (running || step)
        {
            processOp(&state, memory);
            if (state.draw)
            {
                updateScreen(renderer, texture, memory, pixels);
                state.draw = false;
            }
            processInput(&state, keyStates);

            step = false;
        }
        if (keyStates[SDL_SCANCODE_SPACE])
        {
            SDL_Log("Pause toggled");
            // so we don't untoggle too fast
            SDL_Delay(1000);
            running = running ? false : true;
        }
        if (keyStates[SDL_SCANCODE_RETURN])
        {
            SDL_Log("Stepping through");
            step = true;
        }
        // more for quit than anything else?
        while (SDL_PollEvent(&event))
        {
            processEvent(&state, &event);
        }
        SDL_Delay(100);
    }
{% endhighlight %}

We can see that working through the logs:

```
INFO: Pause toggled
INFO: Stepping through
INFO: Decoding a202 (A:a, B:2, C:0, D:2)
INFO: Stepping through
INFO: Decoding dab4 (A:d, B:a, C:b, D:4)
INFO: Stepping through
INFO: Decoding 6b10 (A:6, B:b, C:1, D:0)
```

## Animating a sprite

The aim here is to write a small ROM (in assembly) that animates a sprite. This will hopefully show us what we might be doing wrong.

Picking the right sprite was the hardest bit. Thankfully there are free tools like [pixilart](https://www.pixilart.com/draw) that make this easy. I'm not much of an artist but this looked alien-like enough for me:

```
 #    #   01000010
  #  #    00100100
 ######   01111110
## ## ##  11011011
########  11111111
 ######   01111110
  #  #    00100100
  ####    00111100
```

As I started to look through this I realised I made 2 mistakes. The first is that I took `x,y` to be absolute coordinates whereas the specs specify those are *registers* - that's the easy fix. The second mistake was to assume you always wrote pixels at 8-bit boundaries. Consider the top row of the sprite:

```
Step 1 - (0,0): 0100000010 (0,8): 00000000
Step 2 - (0,0): 0010000001 (0,8): 00000000
Step 3 - (0,0): 0001000000 (0,8): 10000000
```

Shifting the bit pattern doesn't happen in multiples of 8. If we update a pattern at `(0,3)` it will cause 2 memory addresses to change:
```
Current pixels: (0,0): 01100111 (0,8): 01100001
New pixels:     (0,0):    10100 (0,8): 110
End result:     (0,0): 01110100 (0,8): 11000001
```

Now because this implementation stores the state of the pixels in memory, we store them in groups of 8 bits - so updating pixels at places other than boundaries is a little trickier. Thankfully we do already have the code to convert a byte array into individual pixels, and doing the opposite isn't too hard either. You've been warned though, this code is overly complex for what it does (we don't need to convert a whole row to a bit array, we should be able to do this on at most 2 memory addresses). But hey - we can clean that up later.

{% highlight c %}
void setPixels(State *state, uint8_t regCol, uint8_t regRow, uint8_t height, uint8_t memory[])
{
    uint8_t flipped = 0;
    uint8_t xCoord = state->registers[regCol];
    uint8_t yCoord = state->registers[regRow];
    for (int row = 0; row < height; row++)
    {
        // we wrap around
        uint16_t rowStart = MEM_DISPLAY_START + (SCREEN_WIDTH/8)*( (yCoord+row)%SCREEN_HEIGHT);
        // convert the whole line as a bit-array
        bool bitArray[SCREEN_WIDTH];
        uint8_t pixelIndex = 0;
        for (int colGroup = 0; colGroup < SCREEN_WIDTH / 8; colGroup++)
        {
            uint8_t values = memory[rowStart+colGroup];
            // we now bit-shift to get the state of each pixel
            for (int shift = 7; shift >= 0; shift--)
            {
                bitArray[pixelIndex++] = ((values >> shift) & 0x1) ? true : false;
            }
        }
        // flip the pixels
        // in memory, the bit patterns are stored consecutively
        uint8_t bitPattern = memory[state->i+row];
        for (int shift = 7; shift >= 0; shift--) {
            if ((xCoord + shift) > SCREEN_WIDTH) {
                // we're off screen, do nothing
            } else {
                if (bitArray[xCoord + shift] ^ ((bitPattern >> shift))) {
                    flipped = 1;
                }
                bitArray[xCoord + 7-shift] = (bitPattern >> shift) & 0x1;
            }
        }
        // rewrite as uint8_t ints
        pixelIndex = 0;
        for (int colGroup = 0; colGroup < SCREEN_WIDTH / 8; colGroup++) {
            uint8_t value = 0;
            for (int shift=0; shift <8; shift++ ) {
                uint8_t val = bitArray[pixelIndex++] ? 1 : 0;
                value <<= 1;
                value |= val;
            }
            memory[rowStart+colGroup] = value;
        }

    }
    state->draw = flipped ? true : false;
    state->registers[0xf] = state->draw ? 1 : 0;
    state->pc += 2;
}
{% endhighlight %}

The following test ROM will slide the alien's face down the screen every second (based on the timer):
```
        0xa2, 0x04, // set i to x204
        0x12, 0x0c, // jump to the start of the program
        0x42, 0x24, // alien sprite start
        0x7e, 0xdb,
        0xff, 0x7e,
        0x24, 0x3c, // alien sprite end
        0x61, 0x0,  // r1=0
        0x62, 0x0,  // r2=0
        0x0, 0xe0,  // DISP: clear display
        0xd1, 0x28, // display sprite
        0x71, 0x01, // r1 += 1
        0x72, 0x01, // r2 += 1
        0x65, 0x3c, // r5 = 60
        0xf5, 0x15, // set the timer to r5
        0xf5, 0x07, // CHECK_TIMER: r5 = delay timer value
        0x35, 0x00, // if r5 (the timer value) is 0, skip the next instructions
        0x12, 0x1c, // jump back to CHECK_TIMER
        0x12, 0x10, // jump back to DISP
```

Once we're satisfied this works, let's re-run the test ROM:


![display](../../img/chip8/chip8_debugging-2.png)

Success!

# Timers & timings

I left this till the end because... I wasn't sure how I wanted to deal with it. After some (light) reading, I think the approach below should do the trick.

To start, let's note that CHIP-8 timers (both the delay and the sound) run at 60Hz - this roughly translates to a tick every 0.0167 seconds. In other words, the timers should be decremented every 0.0167 seconds.

Leaving that aside, how many opcodes should we process per time step? The answer is a bit more complicated in that it really is "as many as we can but no more than". The CHIP-8 virtual CPU runs at around 500Hz, or 500 cycles per second. We can make the assumption that each opcode takes one cycle to process (it doesn't really - some might take more where e.g. memory access is required).

Combining both together, the pseudo-code for the loop goes like this:

```
clockSpeed = 500
timerDelta = 1/60.0
accumulator = 0
currTime = now()
while (running)
{
  newNow = now()
  elapsedTime = newNow - currTime
  numCycles = int(elapsedTime*clockSpeed)
  if (numCycles > 1)
  {
    currTime = newNow
    timePerCycle = elapsedTime/numCycles
    while (numCycles > 1)
    {
      processOp
      updateDisplay
      accumulator += timePerCycle
      while (accumulator > timerDelta)
      {
        if (delayTimer > 0) delayTimer -= 1
        if (soundTimer > 0) soundTimer -= 1
        accumulator -= timerDelta
      }
    }
  }
}
```

This places a lower bound on the execution - if we process operations faster than 500Hz (500 cycles per second), we'll just wait until enough time has elapsed that we need to process something. The (potential) downside though is that updating the display isn't bound at all - so we could end up updating the display faster than our graphics subsystem can process the update (remember we're updating a texture in-place). It's probably fine to move the `updateDisplay` procedure along with the timer - we're unlikely to want to redraw the screen more than 60fps.
