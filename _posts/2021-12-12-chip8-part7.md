---
layout: post
title: chip8-part7
excerpt: "Writing a CHIP8 interpreter in C - debugging, ironing out bugs (wip)"
categories: [coding]
tags: [howto]
---

So it'd be great to say we're done - but there are still a couple of things to iron out.

# Test ROM

The [test ROM](https://github.com/corax89/chip8-test-rom) by `corax89` is really handy - when run it will validate instructions and assuming you have the `disp` instruction working (`0xdxyn`) it will output one of `ok` or `no` for each instruction type.

I took it for a spin and was greeted by 3 things. The first was that it completed before I could make any sense of what happened - so I added a `SDL_Delay(200);` after each iteration to slow things down (told you that timing thing would come back to haunt us...). The second was that every status code is displayed in the middle of the screen instead of in a grid format (woops). The third was a bunch of `no` statuses for my "set register to register" and subtraction operations:

![display](../../img/chip8/chip8_debugging-1.png)

A quick glance at the code showed that I had swapped registers `x` and `y` around:

```
diff --git a/src/mylib.c b/src/mylib.c
index 8901755..0740405 100644
--- a/src/mylib.c
+++ b/src/mylib.c
@@ -102,7 +102,7 @@ void jumpIfRegNotEqualToReg(State *state, uint8_t reg1, uint8_t reg2)
 }
 void setRegisterToRegister(State *state, uint8_t reg1, uint8_t reg2)
 {
-    state->registers[reg2] = state->registers[reg1];
+    state->registers[reg1] = state->registers[reg2];
     state->pc += 2;
 }
 void setRegisterToBitwiseOr(State *state, uint8_t reg1, uint8_t reg2)
```

For subtraction I messed up the `mod 255` operation:
```
@@ -143,15 +143,14 @@ void addRegisters(State *state, uint8_t reg1, uint8_t reg2)
 void subtractRegisters(State *state, uint8_t reg1, uint8_t reg2)
 {
     bool needBorrow = state->registers[reg2] > state->registers[reg1];
-    state->registers[reg1] = (state->registers[reg1] - state->registers[reg2]) + (needBorrow ? 0xff : 0);
-    // if we need a borrow, this is set  0
+    state->registers[reg1] = (state->registers[reg1] - state->registers[reg2]) % 0xff;
     state->registers[0xf] = needBorrow ? 0 : 1;
     state->pc += 2;
 }
 void subtractRightFromLeft(State *state, uint8_t reg1, uint8_t reg2)
 {
     bool needBorrow = state->registers[reg1] > state->registers[reg2];
-    state->registers[reg1] = (state->registers[reg2] - state->registers[reg1]) + (needBorrow ? 0xff : 0);
+    state->registers[reg1] = (state->registers[reg2] - state->registers[reg1]) % 0xff;
     // if we need a borrow, this is set  0
     state->registers[0xf] = needBorrow ? 0 : 1;
     state->pc += 2;
```

Fixing those and running the test ROM again gave me the all clear. But I couldn't readily tell what was wrong with the display.

# Fixing the display

## Controlling execution

One thing that I wanted was the ability to suspend execution - to be able to log some of the state (e.g. dump the registers, show the memory, ...), and resume/step through instructions. So I changed the main loop to this such that pressing space would suspend/resume execution, and pressing return would step through the next instruction (before suspending again).

{% highlight c %}
    bool running = true;
    bool step = false;
    while (!state.quit)
    {
        if (running || step)
        {
            processOp(&state, memory);
            if (state.draw)
            {
                updateScreen(renderer, texture, memory, pixels);
                state.draw = false;
            }
            processInput(&state, keyStates);

            step = false;
        }
        if (keyStates[SDL_SCANCODE_SPACE])
        {
            SDL_Log("Pause toggled");
            // so we don't untoggle too fast
            SDL_Delay(1000);
            running = running ? false : true;
        }
        if (keyStates[SDL_SCANCODE_RETURN])
        {
            SDL_Log("Stepping through");
            step = true;
        }
        // more for quit than anything else?
        while (SDL_PollEvent(&event))
        {
            processEvent(&state, &event);
        }
        SDL_Delay(100);
    }
{% endhighlight %}

We can see that working through the logs:

```
INFO: Pause toggled
INFO: Stepping through
INFO: Decoding a202 (A:a, B:2, C:0, D:2)
INFO: Stepping through
INFO: Decoding dab4 (A:d, B:a, C:b, D:4)
INFO: Stepping through
INFO: Decoding 6b10 (A:6, B:b, C:1, D:0)
```

# Timers & timings

...
