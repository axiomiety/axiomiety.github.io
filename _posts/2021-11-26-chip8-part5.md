---
layout: post
title: chip8-part5
excerpt: "Writing a CHIP8 interpreter in C - more opcodes (WIP)"
categories: [coding]
tags: [howto]
---

Continuing from the previous post, we'll implement more of the codes defined [here](https://en.wikipedia.org/wiki/CHIP-8#Opcode_table).


# Setting registers - `0x6xnn, 0x7xnn`

Those 2 operations are relatively straight forward. The only "edge" case is what happens when the sum instruction `0x7` results in a number greater to `0xff`. Let's illustrate with a test:

{% highlight c %}
static void test_const(void **state)
{
    /*
    The test ROM will look like this:
        0x0200 0x6001 # set register 0 to 0x1
        0x0202 0x6cab # set register c to to 0xab
        0x0204 0x70ff # add 0xff to register 0 - carry flag remains unchanged
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0x60, 0x01, 0x6c, 0xab, 0x70, 0xff};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 6);

    // let's make sure our registers are all 0
    for (int i=0l;i < 0xf; i++){
        assert_int_equal(chip8State.registers[i], 0);
    }
    processOp(&chip8State, memory);
    // register 0 should be set to 1
    assert_int_equal(chip8State.registers[0], 0x1);
    processOp(&chip8State, memory);
    // register c should be set to 0xab
    assert_int_equal(chip8State.registers[0xc], 0xab);
    processOp(&chip8State, memory);
    // and adding such that it overflows discards any other digits
    assert_int_equal(chip8State.registers[0], 0x0);
    // and the carry flag hasn't changed
    assert_int_equal(chip8State.registers[0xf], 0x0);
}
{% endhighlight %}

Running the test gives us `INFO: Unknown/unimplemented opcode 6001`, so let's add those to `processOp`'s growing `switch` statement:


{% highlight c %}
    case (0x6):
        setRegister(state, opCodeB, opCodeRight);
        break;
    case (0x7):
        addToRegister(state, opCodeB, opCodeRight);
        break;
{% endhighlight %}

where:

{% highlight c %}
void setRegister(State *state, uint8_t reg, uint8_t opCodeRight) {
    // reg is a byte long, but we only care for the last 4 bits
    state->registers[reg] = opCodeRight;
    state->pc += 2;
}
void addToRegister(State *state, uint8_t reg, uint8_t opCodeRight) {
    // reg is a byte long, but we only care for the last 4 bits
    state->registers[reg] = (state->registers[reg] + opCodeRight) & 0xff;
    state->pc += 2;
}
{% endhighlight %}

And the test passes first time:

```
...
[ RUN      ] test_const
INFO: Decoding 6001 (A:6, B:0, C:0, D:1)
INFO: Decoding 6cab (A:6, B:c, C:a, D:b)
INFO: Decoding 70ff (A:7, B:0, C:f, D:f)
[       OK ] test_const
[==========] 3 test(s) run.
[  PASSED  ] 3 test(s).
```

# Conditionals - `0x3xnn, 0x4xnn, 0x5xy0, 0x9xy0`

All 3 instructions essentially skip the next instruction (so we increment our program counter by 4 bytes instead of 2) if they evaluate to true. The first 2 compare registers to scalar values and the last one compares 2 registers.

As usualy, let's start with a test:

{% highlight c %}
static void test_cond(void **state)
{
    /*
    The test ROM will look like this:
        0x0200 0x31ab # compare register 1 to 0xab, jump over if equal to 0xab
        0x0202 0x61ab # set register 1 to 0xab
        0x0204 0x41ab # compare register 1 to 0xab, jump over if not equal to 0xab
        0x0206 0x62ab # set register 2 to 0xab
        0x0208 0x5100 # compare register 1 to register 0, jump over if equal
        0x020a 0x9120 # compare register 1 to register 2, jump over if equal
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0x31, 0xab, 0x61, 0xab, 0x41, 0xab, 0x62, 0xab, 0x51, 0x0, 0x91, 0x20};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 12);

    processOp(&chip8State, memory);
    // we should not have skipped over 0x0202
    assert_int_equal(chip8State.pc, 0x202);
    // set register 1 to 0xab
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x204);
    // compare
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x206);
    // set register 2 to 0xab
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x208);
    // compare register 1 and register 0, jump if equal
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x20a);
    // compare register 1 and register 2, jump if not equal
    processOp(&chip8State, memory);
    // they're both the same so we should just be at the next isntruction
    assert_int_equal(chip8State.pc, 0x20c);
}

{% endhighlight %}

The `jump` instructions are pretty straight forward to implement:

{% highlight c %}
void jumpIfRegEqualToConst(State *state, uint8_t reg, uint8_t value)
{
    state->pc += (state->registers[reg] == value) ? 4 : 2;
}
void jumpIfRegNotEqualToConst(State *state, uint8_t reg, uint8_t value)
{
    state->pc += (state->registers[reg] != value) ? 4 : 2;
}
void jumpIfRegEqualToReg(State *state, uint8_t reg1, uint8_t reg2)
{
    state->pc += (state->registers[reg1] == state->registers[reg2]) ? 4 : 2;
}
void jumpIfRegNotEqualToReg(State *state, uint8_t reg1, uint8_t reg2)
{
    state->pc += (state->registers[reg1] != state->registers[reg2]) ? 4 : 2;
}
void setRegisterToRegister(State *state, uint8_t reg1, uint8_t reg2)
{
    state->registers[reg2] = state->registers[reg1];
    state->pc += 2;
}
{% endhighlight %}

We just need to make sure than when passing the 2nd argument for `0x5xy0` we pass in `y` and not `y0`:


{% highlight c %}
    case (0x3):
        jumpIfRegEqualToConst(state, opCodeB, opCodeRight);
        break;
    case (0x4):
        jumpIfRegNotEqualToConst(state, opCodeB, opCodeRight);
        break;
    case (0x5):
        jumpIfRegEqualToReg(state, opCodeB, opCodeC);
        break;
    case (0x9):
        jumpIfRegNotEqualToReg(state, opCodeB, opCodeC);
        break;
{% endhighlight %}

# Assignment - `0x8xy0`

The test is quite simple:

{% highlight c %}
static void test_assign(void **state)
{
    /*
    The test ROM will look like this:
        0x0200 0x61ab # set register 1 to 0xab
        0x0202 0x8120 # set register 2 to the same value as register 1
        0x0204 0x5120 # compare regsiter 1 and 2, jump over if equal
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0x61, 0xab, 0x81, 0x20, 0x51, 0x20};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 6);

    // make sure both regs are 0 at the start
    assert_int_equal(chip8State.registers[1], 0x0);
    assert_int_equal(chip8State.registers[2], 0x0);
    // assign 0xab to register 1
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.registers[1], 0xab);
    // set register 2 to register 1
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.registers[2], 0xab);
    // compare both registers
    processOp(&chip8State, memory);
    // they should be equal, so the pc should have incremented by 4
    assert_int_equal(chip8State.pc, 0x208);
}
{% endhighlight %}

And the same goes for the implementation:

{% highlight c %}
void setRegisterToRegister(State *state, uint8_t reg1, uint8_t reg2)
{
    state->registers[reg2] = state->registers[reg1];
    state->pc += 2;
}
{% endhighlight %}

Note that for all `0x8xyz` instructions the last 4 bits, `z`, dictate what happens between registers `x` and `y` - so that's what the nested `switch` switches on:


{% highlight c %}
    case (0x8):
    {
        switch (opCodeD)
        {
        case (0x0):
            setRegisterToRegister(state, opCodeB, opCodeC);
            break;
        default:
            error = true;
            break;
        }
    }
    break;
{% endhighlight %}

# Bitwise operations, operators - `0x8xy1, 0x8xy2, 0x8xy3`

This being C, it's straight-forward:


{% highlight c %}
static void test_bitwise_operators(void **state)
{
    /*
    The test ROM will look like this:
        0x0200 0x610f # set register 1 to 0x0f
        0x0202 0x62f0 # set register 2 to 0xf0
        0x0204 0x8121 # set register 1 to r1 | r2
        0x0206 0x8112 # set register 1 to r1 & r1
        0x0208 0x8113 # set register 1 to r1 ^ r1
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0x61, 0x0f, 0x62, 0xf0, 0x81, 0x21, 0x81, 0x12, 0x81, 0x13};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 10);

    // set the regs
    processOp(&chip8State, memory);
    processOp(&chip8State, memory);
    // |=
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.registers[1], 0xff);
    // &=
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.registers[1], 0xff);
    // ^=
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.registers[1], 0x0);
}
{% endhighlight %}

Ditto for the implementation:

{% highlight c %}
void setRegisterToBitwiseOr(State *state, uint8_t reg1, uint8_t reg2)
{
    state->registers[reg1] |= state->registers[reg2];
    state->pc += 2;
}
void setRegisterToBitwiseAnd(State *state, uint8_t reg1, uint8_t reg2)
{
    state->registers[reg1] &= state->registers[reg2];
    state->pc += 2;
}
void setRegisterToBitwiseXor(State *state, uint8_t reg1, uint8_t reg2)
{
    state->registers[reg1] ^= state->registers[reg2];
    state->pc += 2;
}
{% endhighlight %}
And the addition to `processOp`:


{% highlight c %}
    case (0x8):
    {
        switch (opCodeD)
        {
        case (0x0):
            setRegisterToRegister(state, opCodeB, opCodeC);
            break;
        case (0x1):
            setRegisterToBitwiseOr(state, opCodeB, opCodeC);
            break;
        case (0x2):
            setRegisterToBitwiseAnd(state, opCodeB, opCodeC);
            break;
        case (0x3):
            setRegisterToBitwiseXor(state, opCodeB, opCodeC);
            break;
        default:
            error = true;
            break;
        }
    }
{% endhighlight %}

# Bitwise operations, bit shifting - `0x8xy6, 0x8xye`

TBC

# Conclusion

TBC
