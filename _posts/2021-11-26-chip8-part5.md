---
layout: post
title: chip8-part5
excerpt: "Writing a CHIP8 interpreter in C - more opcodes (WIP)"
categories: [coding]
tags: [howto]
---

Continuing from the previous post, we'll implement more of the codes defined [here](https://en.wikipedia.org/wiki/CHIP-8#Opcode_table).


# Setting registers - `0x6xnn, 0x7xnn`

Those 2 operations are relatively straight forward. The only "edge" case is what happens when the sum instruction `0x7` results in a number greater to `0xff`. Let's illustrate with a test:

{% highlight c %}
static void test_const(void **state)
{
    /*
    The test ROM will look like this:
        0x0200 0x6001 # set register 0 to 0x1
        0x0202 0x6cab # set register c to to 0xab
        0x0204 0x70ff # add 0xff to register 0 - carry flag remains unchanged
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0x60, 0x01, 0x6c, 0xab, 0x70, 0xff};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 6);

    // let's make sure our registers are all 0
    for (int i=0l;i < 0xf; i++){
        assert_int_equal(chip8State.registers[i], 0);
    }
    processOp(&chip8State, memory);
    // register 0 should be set to 1
    assert_int_equal(chip8State.registers[0], 0x1);
    processOp(&chip8State, memory);
    // register c should be set to 0xab
    assert_int_equal(chip8State.registers[0xc], 0xab);
    processOp(&chip8State, memory);
    // and adding such that it overflows discards any other digits
    assert_int_equal(chip8State.registers[0], 0x0);
    // and the carry flag hasn't changed
    assert_int_equal(chip8State.registers[0xf], 0x0);
}
{% endhighlight %}

Running the test gives us `INFO: Unknown/unimplemented opcode 6001`, so let's add those to `processOp`'s growing `switch` statement:


{% highlight c %}
    case (0x6):
        setRegister(state, opCodeB, opCodeRight);
        break;
    case (0x7):
        addToRegister(state, opCodeB, opCodeRight);
        break;
{% endhighlight %}

where:

{% highlight c %}
void setRegister(State *state, uint8_t reg, uint8_t opCodeRight) {
    // reg is a byte long, but we only care for the last 4 bits
    state->registers[reg] = opCodeRight;
    state->pc += 2;
}
void addToRegister(State *state, uint8_t reg, uint8_t opCodeRight) {
    // reg is a byte long, but we only care for the last 4 bits
    state->registers[reg] = (state->registers[reg] + opCodeRight) & 0xff;
    state->pc += 2;
}
{% endhighlight %}

And the test passes first time:

```
...
[ RUN      ] test_const
INFO: Decoding 6001 (A:6, B:0, C:0, D:1)
INFO: Decoding 6cab (A:6, B:c, C:a, D:b)
INFO: Decoding 70ff (A:7, B:0, C:f, D:f)
[       OK ] test_const
[==========] 3 test(s) run.
[  PASSED  ] 3 test(s).
```

# Conditionals - `0x3xnn, 0x4xnn, 0x5xy0`

All 3 instructions essentially skip the next instruction (so we increment our program counter by 4 bytes instead of 2) if they evaluate to true.

As usualy, let's start with a test:

{% highlight c %}

{% endhighlight %}

# Conclusion

That's 5 more op codes done! 9 down, 27 to go.
