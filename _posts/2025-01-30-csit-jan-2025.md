---
layout: post
title: csit-writeup - jan-2025
excerpt: "Writeup for the CIST Jan 2025 reverse engineering mini challenge."
categories: [writeup]
tags: [itsec, wargame]
---

* TOC
{:toc}

# Prelims

CSIT is a government institution - and whilst they most certainly have the capabilities to see what I'm writing as I'm writing it, no point making it easy. Let's grab the provided artifact but let's do this in a container!

Start by installing `podman`: `brew install podman`. Initialising is easy - `podman machine init` followed by `podman machine start` (note that if you reboot your host machine you'll need to re-run `podman machine start`). Now let's use a debian base image. The latest available is `trixie`:

```
~/tmp ❯❯❯ podman run --name sandbox -h sandbox -it docker.io/debian:trixie
Trying to pull docker.io/library/debian:trixie...
Getting image source signatures
Copying blob sha256:e5e40a2b9fe32b2158c946023b700f61f57f567701b6be2e04192bbcc68fb32d
Copying config sha256:e05898b0463444d478837b2a23b58dce9c9848aecdb87e8df8b811338ca26b8b
Writing manifest to image destination
root@sandbox:/# 
```

We now have an isolated environment in which to download the `.zip` provided. However it's totally bare, so let's add a few packages that will make our live easier:

```
# apt update
# apt install curl binutils binutils-common unzip file llvm gzip git build-essential vim zlib1g-dev cmake tcpdump
```

# `runes.zip`

Let's goooo!

```
root@sandbox:/tmp# curl -s -L https://go.gov.sg/ancient-runes -o runes.zip
root@sandbox:/tmp# unzip -l runes.zip
Archive:  runes.zip
  Length      Date    Time    Name
---------  ---------- -----   ----
  9144168  2025-01-13 14:23   client
  9144888  2025-01-13 14:22   dev_server
    29716  2025-01-20 14:24   #U86c7#U5e74#U5409#U7965.pcapng
---------                     -------
 18318772                     3 files
```

So 2 files and a `pcapng` packet capture. That sounds interesting. Let's extract and see:

```
root@sandbox:/tmp# mkdir extract
root@sandbox:/tmp# unzip runes.zip -d extract/
Archive:  runes.zip
  inflating: extract/client          
  inflating: extract/dev_server      
  inflating: extract/#U86c7#U5e74#U5409#U7965.pcapng  
root@sandbox:/tmp# cd extract/
root@sandbox:/tmp/extract# file client dev_server 
client:     ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8485f6953c06d12b9865185ba3466fdbf9b4a65c, for GNU/Linux 2.6.32, stripped
dev_server: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8485f6953c06d12b9865185ba3466fdbf9b4a65c, for GNU/Linux 2.6.32, stripped
root@sandbox:/tmp/extract# 
```

# Extracting 

So both `client` and `dev_server` are ELF binaries. As per the hint, those are likely installers from which we need to extract python modules. Let's start with `client`:

```
root@sandbox:/tmp/extract# llvm-objdump -h client | grep pydata
 26 pydata             008a9c93 0000000000000000 
```

Sure enough, it is. Let's extract it:

```
root@sandbox:/tmp/extract# llvm-objcopy --dump-section pydata=pydata.client.dump client 
root@sandbox:/tmp/extract# file pydata.client.dump 
pydata.client.dump: zlib compressed data
```

The section is essentially a compressed stream. As per the linked document we need a copy of `pyinstxtractor` to extract the `.pyc` files from the `.pydata` section. Thankfully it's a single python script so we can run it from the default interpreter:

```
root@sandbox:/tmp/extract# curl -s https://raw.githubusercontent.com/extremecoders-re/pyinstxtractor/refs/heads/master/pyinstxtractor.py -o pyinstxtractor.py
root@sandbox:/tmp/extract# python3 pyinstxtractor.py pydata.client.dump 
[+] Processing pydata.client.dump
[+] Pyinstaller version: 2.1+
[+] Python version: 3.10
[+] Length of package: 9084051 bytes
[+] Found 98 files in CArchive
[+] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap.pyc
[+] Possible entry point: pyi_rth_inspect.pyc
[+] Possible entry point: pyi_rth_pkgutil.pyc
[+] Possible entry point: pyi_rth_multiprocessing.pyc
[+] Possible entry point: client.pyc
[!] Warning: This script is running in a different Python version than the one used to build the executable.
[!] Please run this script in Python 3.10 to prevent extraction errors during unmarshalling
[!] Skipping pyz extraction
[+] Successfully extracted pyinstaller archive: pydata.client.dump

You can now use a python decompiler on the pyc files within the extracted directory
```

Mmm there's a warning - so this was created using python 3.10, which is a fair bit older than the system-installed verison:
```
root@sandbox:/tmp/extract# python3 --version
Python 3.13.1
```

For the sake of completeness, let's get python 3.10 installed. Unfortunately it's no longer packaged so we'll have to install this from source. No biggie:

```
root@sandbox:/tmp/extract# curl -s https://www.python.org/ftp/python/3.10.0/Python-3.10.0.tgz -o Python-3.10.0.tgz
root@sandbox:/tmp/extract# tar xvf Python-3.10.0.tgz
...
root@sandbox:/tmp/extract# cd Python-3.10.0/
root@sandbox:/tmp/extract/Python-3.10.0# ./configure 
...
root@sandbox:/tmp/extract/Python-3.10.0#  make
...
```

The `make` step will take a a few minutes while depending on how performant your system is. Use `-j <number of cores>` to speed this up across multiple cores.

Once it's done, let's just create a `venv` (this will ensure `python3` refers to the one we just installed):

```
root@sandbox:/tmp/extract/Python-3.10.0# ./python -m venv venv
root@sandbox:/tmp/extract/Python-3.10.0# source venv/bin/activate
(venv) root@sandbox:/tmp/extract/Python-3.10.0# cd ../          
(venv) root@sandbox:/tmp/extract# python --version
Python 3.10.0
```

Now let's extract the data again:

```
(venv) root@sandbox:/tmp/extract# python pyinstxtractor.py pydata.client.dump 
[+] Processing pydata.client.dump
[+] Pyinstaller version: 2.1+
[+] Python version: 3.10
[+] Length of package: 9084051 bytes
[+] Found 98 files in CArchive
[+] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap.pyc
[+] Possible entry point: pyi_rth_inspect.pyc
[+] Possible entry point: pyi_rth_pkgutil.pyc
[+] Possible entry point: pyi_rth_multiprocessing.pyc
[+] Possible entry point: client.pyc
[+] Found 282 files in PYZ archive
[+] Successfully extracted pyinstaller archive: pydata.client.dump

You can now use a python decompiler on the pyc files within the extracted directory
```

No warnings! We can see a couple of `.pyc` files. The one we're interested in is `client.pyc`. However we can't peek inside as-is:
```
(venv) root@sandbox:/tmp/extract/pydata.client.dump_extracted# file client.pyc 
client.pyc: Byte-compiled Python module for CPython 3.10, timestamp-based, .py timestamp: Thu Jan  1 00:00:00 1970 UTC, .py size: 0 bytes
(venv) root@sandbox:/tmp/extract/pydata.client.dump_extracted# head -2 client.pyc
o
�@s�ddlmZddlZddlZddlZddlZddlZddlZddZ    ddl
```

For this we'll need to decompile the bytecode. 

# Decompling the `.pyc` files

`pycdc` is a tool that does just that:

```
(venv) root@sandbox:/tmp/extract# git clone https://github.com/zrax/pycdc.git
Cloning into 'pycdc'...
remote: Enumerating objects: 2914, done.
remote: Total 2914 (delta 0), reused 0 (delta 0), pack-reused 2914 (from 1)
Receiving objects: 100% (2914/2914), 895.05 KiB | 20.34 MiB/s, done.
Resolving deltas: 100% (1837/1837), done.
```

Just like  `python`, we'll need to build the binaries:
```
(venv) root@sandbox:/tmp/extract# cd pycdc/
(venv) root@sandbox:/tmp/extract/pycdc# mkdir build && cd build && cmake ..
-- The C compiler identification is GNU 14.2.0
-- The CXX compiler identification is GNU 14.2.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found Python3: /tmp/extract/Python-3.10.0/venv/bin/python3 (found suitable version "3.10.0", minimum required is "3.6") found components: Interpreter
-- Configuring done (0.3s)
-- Generating done (0.0s)
-- Build files have been written to: /tmp/extract/pycdc/build
(venv) root@sandbox:/tmp/extract/pycdc/build# make
[  2%] Building CXX object CMakeFiles/pycxx.dir/bytecode.cpp.o
...
[ 97%] Building CXX object CMakeFiles/pycdc.dir/ASTNode.cpp.o
[100%] Linking CXX executable pycdc
[100%] Built target pycdc
(venv) root@sandbox:/tmp/extract/pycdc/build# 
```

Let's take it for a spin:

```
(venv) root@sandbox:/tmp/extract# pycdc/build/pycdc pydata.client.dump_extracted/client.pyc | tail -5
Unsupported opcode: BEFORE_ASYNC_WITH (94)
Unsupported opcode: BEFORE_ASYNC_WITH (94)
    asyncio.run(send_commands(uri, headerss, logging))

if __name__ == '__main__':
    start_client()
    return None
```

Huh. So it turns out that certain opscode aren't supported by `pycdc` - in other words, it's unable to decompile a `.pyc` that makes use of certain features. We can use `pcdas` tos how the actual byte code:

```
(venv) root@sandbox:/tmp/extract# pycdc/build/pycdas pydata.client.dump_extracted/client.pyc | grep BEFORE_AS
                18      BEFORE_ASYNC_WITH               
                18      BEFORE_ASYNC_WITH  
```

Hint #2 mentions a corgi and issue #234. The issue was easy enough to [find](https://github.com/zrax/pycdc/issues/234) but the corgi part had me stumped for a while until I came across [that post](https://corgi.rip/blog/pyinstaller-reverse-engineering/) (which actually links back to issue 234!). Unfortunately the `pycdc` project has moved on quite a bit since this was written meaning (1) the code changed and (2) the line numbers no longer line up.

I added the missing codes one by one (don't forget to call `make` again after applying those changes):

```
(venv) root@sandbox:/tmp/extract/pycdc# git diff
diff --git a/ASTree.cpp b/ASTree.cpp
index 1f419d0..889a8ce 100644
--- a/ASTree.cpp
+++ b/ASTree.cpp
@@ -1036,6 +1036,12 @@ PycRef<ASTNode> BuildFromCode(PycRef<PycCode> code, PycModule* mod)
         case Pyc::JUMP_IF_TRUE_A:
         case Pyc::JUMP_IF_FALSE_OR_POP_A:
         case Pyc::JUMP_IF_TRUE_OR_POP_A:
+        case Pyc::BEFORE_ASYNC_WITH:
+        case Pyc::SETUP_ASYNC_WITH_A:
+        case Pyc::RERAISE:
+        case Pyc::RERAISE_A:
+        case Pyc::JUMP_IF_NOT_EXC_MATCH_A:
+        case Pyc::END_ASYNC_FOR:
         case Pyc::POP_JUMP_IF_FALSE_A:
         case Pyc::POP_JUMP_IF_TRUE_A:
         case Pyc::POP_JUMP_FORWARD_IF_FALSE_A:
```

Certain things are still unsupported
```
(venv) root@sandbox:/tmp/extract/pycdc/build# ./pycdc ../../pydata.client.dump_extracted/client.pyc | grep Unsupported
Warning: Stack history is not empty!
Warning: block stack is not empty!
Unsupported Node type: 28
Unsupported Node type: 28
Unsupported Node type: 28
Unsupported Node type: 28
Warning: Stack history is not empty!
Warning: block stack is not empty!
Unsupported Node type: 28
Unsupported Node type: 28
Unsupported Node type: 28
```

but at least the output resembles something you could *almost* run through an interpreter!
```
(venv) root@sandbox:/tmp/extract/pycdc/build# ./pycdc ../../pydata.client.dump_extracted/client.pyc 2>&1 | head -30 | tail -6
from common import validate, generate_client_context, generate_random_string
from constants import LOGGING_VERBOSITY, HINT_3
load_dotenv()
logging.basicConfig(LOGGING_VERBOSITY, '%(asctime)s - %(levelname)s - %(message)s', **('level', 'format'))
SERVER_IP = os.getenv('SERVER_IP', '127.127.127.127')
SERVER_PORT = os.getenv('SERVER_PORT', '9999')
```

Let's extract this to a single file:
```
(venv) root@sandbox:/tmp/extract# ./pycdc/build/pycdc pydata.client.dump_extracted/client.pyc > client.py
```

Repeating the steps above for the `server` binary - TL;DR being:
```
(venv) root@sandbox:/tmp/extract# llvm-objcopy --dump-section pydata=pydata.server.dump dev_server 
(venv) root@sandbox:/tmp/extract# python pyinstxtractor.py pydata.server.dump            
(venv) root@sandbox:/tmp/extract# ./pycdc/build/pycdc pydata.server.dump_extracted/dev_server.pyc > server.py
```

# Source code analysis

## `client.py`

The client is pretty basic. It starts by defining a couple of globals:

{% highlight python %}
SERVER_IP = os.getenv('SERVER_IP', '127.127.127.127')
SERVER_PORT = os.getenv('SERVER_PORT', '9999')
WS_IP = os.getenv('WS_IP', '0.0.0.0')
WS_PORT = os.getenv('WS_PORT', '8000')
TIMEOUT = 5
CA_CERT = 'DEV_ca.crt'
CLIENT_CERT = 'DEV_client.crt'
CLIENT_KEY = 'DEV_client.key'
CLIENT_SERVER = f'''http://{SERVER_IP}:{SERVER_PORT}/REVW/'''
{% endhighlight %}

before opening to WebSocket connections to a server, one to receive messages and one to send command:

{% highlight python %}
def start_client():
    _string = generate_random_string()
    headersl = {
        'X-ARBOC': f'''{_string}-listener''' }
    headerss = {
        'X-ARBOC': f'''{_string}-sender''' }
    uri = f'''wss://{WS_IP}:{WS_PORT}/'''
    listener_thread = None((lambda : asyncio.run(listen_messages(uri, headersl, logging))), **('target',))
    listener_thread.daemon = True
    listener_thread.start()
    asyncio.run(send_commands(uri, headerss, logging))
{% endhighlight %}

Parts of the code aren't readily executable - e.g. `await websockets.connect(uri, headers, context, **('additional_headers', 'ssl'))` should actually be `await websockets.connect(uri, additional_headers=headers, ssl=context)`. I originally tried to fix those bits but as we'll see later there's a much simpler way.

## `server.py`

The server is more interesting - first of all, there's a flag!

{% highlight python %}
FLAG = '7eb66acfb3652e80ef006143b4e5b6565b84b51355b26e39d2979a3bc873ba394ecae0061bd9522a9639ac4488733ad97d5e5acfb1e3e6f7'
{% endhighlight %}

But as we see a few lines below, it's encrypted:

{% highlight python %}
                        if command == '88':
                            
                            try:
                                decrypted_message = decrypt_3des(bytes.fromhex(FLAG), bytes.fromhex(args1))
                                if client == senderId:
                                    await clients[client]['listener'].send(f'''s()p3rR00+: {decrypted_message}''')
{% endhighlight %}

Looking at the parsing logic, to trigger the above we'd need to pass in `5n@k3#88#<key in hex>`. The rest of the commands are bogus - they only act on the target but never stream the results back to the client:

{% highlight python %}
                        if command == '01':
                            os.system('ip addr')
                        if command == '33':
                            os.system('hostname')
                        if command == '27':
                            os.system('cat /proc/cpuinfo')
{% endhighlight %}

## `constants.py` and `common.py`

This part looked a little sus, and was present in both `client.py` and `server.py` in similar forms:

{% highlight python %}
from common import validate, generate_server_context, decrypt_3des
from constants import LOGGING_VERBOSITY
{% endhighlight %}

It turns out the local `constants` module was in its own `_extracted` directory - probably a consequence of how it was packaged as an installer:
```
(venv) root@sandbox:/tmp/extract# ./pycdc/build/pycdc pydata.server.dump_extracted/PYZ-00.pyz_extracted/constants.pyc 
# Source Generated with Decompyle++
# File: constants.pyc (Python 3.10)

import logging
import os
from dotenv import load_dotenv
load_dotenv()
LOGGING_VERBOSITY = os.getenv('LOGGING_VERBOSITY', 'NONE')
LOGGING_MORE_VERBOSITY = os.getenv('LOGGING_MORE_VERBOSITY', 'NONE')
if LOGGING_VERBOSITY == 'REG0D' and LOGGING_MORE_VERBOSITY == 'y0uReOnToSomEThinG':
    LOGGING_VERBOSITY = logging.DEBUG
elif LOGGING_VERBOSITY == 'REG0D':
    LOGGING_VERBOSITY = logging.INFO
else:
    LOGGING_VERBOSITY = logging.ERROR
HINT_1 = '[HINT] Have you tried REading the binaries? Where are you downloading them from?'
HINT_2 = '[HINT] Have you tried REading the binaries? Is your SSL Context malformed or what?'
HINT_3 = "[HINT] Have you tried REading the binaries? Bruh we can't make a connection..."
```

`common.py` is more interesting - among other things it looks like the `validate` function will download the certs from a server:

{% highlight python %}
def download_file(url, dest_path, log):
    try:
        with urllib.request.urlopen(url) as response:
            with open(dest_path, 'wb') as f:
                f.write(response.read())
{% endhighlight %}

The `init` method writes a `.env` file with some settings we haven't seen before:

{% highlight python %}
def init():
    if not os.path.exists('.env'):
        env_content = '\nLOGGING_VERBOSITY=REG0D\n\nSERVER_IP=34.57.139.144\nSERVER_PORT=80\n\nWS_IP=\nWS_PORT=\n'
        with open('.env', 'w') as env_file:
            env_file.write(env_content.strip())
...
{% endhighlight %}

# Running the malware



We can't seem to run the `pyc` files alone - we need to install dependencies, even though those were packaged. No trouble, let's just `pip install` them in our `venv`:

```

```

# SSL certs

Explain why we can't connect

# `pcapng` file

I originally dismissed the `pcapng` - I couldn't get much out of it using `tcpdump`:

```
(venv) root@sandbox:/tmp/extract# tcpdump -A -r '#U86c7#U5e74#U5409#U7965.pcapng'  | head -5
reading from file #U86c7#U5e74#U5409#U7965.pcapng, link-type EN10MB (Ethernet), snapshot length 262144
14:23:03.749464 IP localhost.57728 > localhost.1234: Flags [S], seq 854060939, win 65495, options [mss 65495,sackOK,TS val 3991594378 ecr 0,nop,wscale 7], length 0
E..<r.@.@...............2............0.........
............
14:23:03.749466 IP localhost.57730 > localhost.1234: Flags [S], seq 3700194746, win 65495, options [mss 65495,sackOK,TS val 3991594378 ecr 0,nop,wscale 7], length 0
E..<r.@.@.................}..........0.........
tcpdump: Unable to write output: Broken pipe
```

data looked compressed or encrypted. I was hoping I'd see the command required for key but no dice. On a whim I loaded this up in Wireshark. Sure enough the data *was* encrypted. But now that we had keys at our disposal, could we decrypt it?

In newer versions of TLS we have forward secrecy. Having keys are not sufficient to decrypt a communication that happened in the past.


=========

ROUGH NOTES - WILL CLEAN UP

if we decode the cert, we see the same thing!



openssl x509 -in DEV_ca.crt -text

```
(venv) ~/D/csit ❯❯❯ openssl x509 -in DEV_client.crt -text | grep Subject
        Subject: C=JP, ST=Osaka, L=Japan, O=Yamashita Bookoshita, OU=Yamashita Bookoshita, CN=theflag.isnot.here, emailAddress=do.not@bother
        Subject Public Key Info:
            X509v3 Subject Key Identifier: 
```

ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self-signed certificate in certificate chain (_ssl.c:1020)

```
python -m venv
pip install pycryptodome
```

def decrypt_3des(ciphertext = None, key = None):
    iv = ciphertext[:DES3.block_size]
    cipher = DES3.new(key, DES3.MODE_CBC, iv=iv)
    decrypted_data = unpad(cipher.decrypt(ciphertext[DES3.block_size:]), DES3.block_size)
    return decrypted_data.decode()
```

```
            elif len(message) <= 5:
                if client == senderId:
                    await clients[client]['listener'].send('s()p3rR00+: run --help')
                else:
                    parts = message.split('#')
                    if len(parts) > 2:
                        command = parts[1]
                        args1 = parts[2]
```

5n@k3

88

```
...PBFEJJDMPMFJNMHJJADFPBFEICCHPGFDNGHDJADFPJFMIPCKOKEPMKGPIICNPBFEIFCAOAEFJDDGLDBGPCFHIACFOFEAMFGAJCDHOAEFIPCKOBEEIGCDKGADPCFHJKDPPP
...FKNPHKJMDJPDFGIBCEPDFGJGDDPFFAIBCEKBAEODEGJKDPOOELILCOPIFNNIHNJLDOPEFBJJDMPLFOJCDHPMFJJJDMPNFINNHIIJCMOGEDIBCEOEEBJADFPIFNJNDIOPEK
...MPGKIGCDPFFANFHAJEDBPHFCIDCGPGFDJHDCPLFOJHDCOOELMOGLJKDPPCFHJHDCLHBCPCFHICCHONEIIOCLOGEDMGGDJDDGPNFIJEDBOMEJMMGJJIDNPBFEJMDJPJFMIK
...CPPOFLJPDKPCFHICCHKCAHOLEOIFCAKFAAPGFDJDDGPAFFJPDKPBFEJFDAOGEDMGGDIACFOPEKJNDILNBIPOFLJGDDPPFKJBDEPEFBIHCCOCEHMCGHIMCJOJEMJODLLOBL
.$OHECICCHODEGJBDELBBEIDCGLDBGIBCELEBB


```
openssl x509 -req \
    -in device_cert_csr_filename.csr \
    -CA DEV_ca.crt \
    -CAkey DEV_ca.key \
    -CAcreateserial \
    -out device_cert_filename.pem \
    -days 500 -sha256
```

```
penssl genrsa -out client.key 2048
(venv) ~/D/csit ❯❯❯ openssl req -new -key client.key -subj '/CN=116.86.19.207' -out client.csr
(venv) ~/D/csit ❯❯❯ openssl x509 -req -in client.csr -CA DEV_ca.crt -CAkey DEV_ca.key -CAcreateserial -days 365 -out client.crt
```

this has some more details on generating your own cert:
https://github.com/it0dan/mtls

but this: https://medium.com/@nisanth.m.s/unveiling-openssl-a-journey-through-command-line-cryptography-5055756ff68 shows how to add SAN


GOAT

managed to decrypt the websocket traffic via Wireshark

#U86c7#U5e74#U5409#U796

86c7_5e74_5409_796++++

mount gxfc - gong xi fa cai
gōng xǐ fā cái


```
Welcome to the chat!
hi therewelcomeso you are here because nian is coming to kill us all?i seewell i can help you with thatno worries :)i hope you have REad enough into the ancient runesthose are your keys to successas for the key itself, it is the weakness of nian: 红 火 热闹take the 汉语拼音 of those 4 characters, then separate them with a "_" and pad them with 4 plusesoh? missing some bytes?well...oh darn, nian has comeit has bit off both my legsim dying...i dont have time to tell you the last part of the key... but maybe if you look into the SSL certificates...encoding???? i cant remember... it sounds like the acid found in mandarin oranges and other citrus fruits...urgh... im sorry... im losing too much bloodwe are counting on you...
```
