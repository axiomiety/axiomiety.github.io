---
layout: post
title: chip8-part5
excerpt: "Writing a CHIP8 interpreter in C - more opcodes (WIP)"
categories: [coding]
tags: [howto]
---

Continuing from the previous post, we'll implement more of the codes defined [here](https://en.wikipedia.org/wiki/CHIP-8#Opcode_table).

# I-related - `0xannn, 0xfx1e`

The tests:

{% highlight c %}
static void test_memory_set_i(void **state) {
    /*
    The test ROM will look like this:
        0x0200 0xa123 # set i to 0x123
        0x0202 0x6102 # set r1 to 0x2
        0x0204 0xf11e # add the contents of r1 to i
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0xa1, 0x23, 0x61, 0x02, 0xf1, 0x1e};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 6);

    // i should be 0 upon initialisation
    assert_int_equal(chip8State.i, 0x0);
    // i should now be 0x123
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.i, 0x123);
    // set the register
    processOp(&chip8State, memory);
    // add to i
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.i, 0x125);
}
{% endhighlight %}

The only bit of interest implementation-wise is how we concatenate the operands to form a memory address:

{% highlight c %}
void setI(State *state, uint8_t top, uint8_t bottom)
{
    state->i = (top << 8) | bottom;
    state->pc += 2;
}
void addRegToI(State *state, uint8_t reg)
{
    state->i += state->registers[reg];
    state->pc += 2;
}
{% endhighlight %}
# PC-related - `0xbnnn`

This really isn't much:


{% highlight c %}
{% endhighlight %}

And the implementation is equally straight-forward:


{% highlight c %}
{% endhighlight %}

# Storing/loading registers - `0xfx55, 0xf65`

# Displaying sprites - `0xdxyn`

# Keyboard - `0xex9e, 0xexa1, 0xfx0a`

The first 2 are essentially conditionals on key presses. We can mimic that behaviour in our test by setting the appropriate key registers.

Unlike most of our previous tests, we'll run this one twice - once with a key depressed, and one with it pressed:

{% highlight c %}
static void test_keyboard(void  **state) {
    /*
    The test ROM will look like this:
        0x0200 0xe19e # skip the next instruction if key 0x1 is down
        0x0202 0x6001 # set register r0 to 1
        0x0204 0xe1a1 # skip the next instruction if key 0x1 is *not* down

    This test is a little different in that state will be changed from the outside.
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0xe1, 0x9e, 0x60, 0x01, 0xe1, 0xa1};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 6);
    
    // check that key 1 is depressed
    assert_int_equal(chip8State.input[1], false);
    // skip 0x0202 if the key is pressed (which it isn't)
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x202);
    // set the register
    processOp(&chip8State, memory);
    // key 1 is still not pressed so we should skip the next instruction
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, 0x208);

    // now run through this again but setting the key as pressed
    State chip8State2 = {.pc = ROM_OFFSET};
    chip8State2.input[0x1] = true;

    // skip 0x0202 if the key is pressed (which it is this time)
    processOp(&chip8State2, memory);
    assert_int_equal(chip8State2.pc, 0x204);
    // key 1 is still pressed so we should proceed to the next instruction
    processOp(&chip8State2, memory);
    assert_int_equal(chip8State2.pc, 0x206);
}
{% endhighlight %}

The implementation of one is the opposite of the other:

{% highlight c %}
void jumpIfKeyPressed(State *state, uint8_t key)
{
    state->pc += state->input[key] ? 4 : 2;
}
void jumpIfKeyNotPressed(State *state, uint8_t key)
{
    state->pc += state->input[key] ? 2 : 4;
}
{% endhighlight %}

Adding this to `processOp` covers the whole `0xe` block:

{% highlight c %}
    case (0xe):
    {
        switch (opCodeRight)
        {
        case (0x9e):
            jumpIfKeyPressed(state, opCodeB);
            break;
        case (0xa1):
            jumpIfKeyNotPressed(state, opCodeB);
            break;
        default:
            error = true;
            break;
        }
    }
{% endhighlight %}

The last one is a bit trickier as it's a blocking operation - that is, we need to wait until a key is pressed *before* we proceed - and whilst we wait, *nothing* happens. The easiest way to implement this is to simply not increment the program counter until a key is pressed.


{% highlight c %}
static void test_keyboard_blocking(void **state) {
    /*
    The test ROM will look like this:
        0x0200 0xf50a # wait until a key is pressed, store it in r5
    */

    // init
    State chip8State = {.pc = ROM_OFFSET};
    uint8_t memory[MEM_SIZE];
    memset(memory, 0x0, MEM_SIZE * sizeof(uint8_t));
    uint8_t rom[] = {0xf5, 0x0a};
    memcpy(memory + ROM_OFFSET, rom, sizeof(rom[0]) * 2);

    // wait for a key to be pressed
    processOp(&chip8State, memory);
    assert_int_equal(chip8State.pc, ROM_OFFSET);
    // simulate a key getting pressed
    chip8State.input[1] = true;
    // check again
    processOp(&chip8State, memory);
    // we should now proceed to the next instruction
    assert_int_equal(chip8State.pc, 0x202);
    // and register 5 should have value 1
    assert_int_equal(chip8State.registers[0x5], 0x1);
}
{% endhighlight %}

Note that the implementation of this function is stateless - if key 1 is already being pressed, this function will store key 1 into the relevant register and proceed. I don't know if hardware implementations of CHIP-8 support multiple key presses at the same time but for simplicity, we'll assume not for now.

{% highlight c %}
void waitForKey(State *state, uint8_t reg)
{
    // any key that is pressed if valid
    for (int key=0; key<16;key++) {
        if (state->input[key]) {
            state->registers[reg] = key;
            state->pc += 2;
        }
    }
}
{% endhighlight %}

One way I could see working around this is to store some sort of timestamp along with each key press, which would mean making the evaluation loop time-aware. But let's kick this down the road.

# Timers - `0xfx0a, 0xfx18`

# Conclusion

