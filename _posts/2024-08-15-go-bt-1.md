---
layout: post
title: go-bt-1
excerpt: "Write a BitTorrent client from scratch in Go: part 1"
categories: [coding]
tags: [howto,golang]
---

First post in what will (hopefully?) be building an *extremely* simple BitTorrent client in Go. At the very least we'll aimto parse `.torrent` files, connect to peers and download files. Just to managing expectations, incoming requests (uploads), DHT and the like will likely be left as an exercise to the reader.

# `bencode`

If you have ever downloaded a `.torrent` file from say, [Ubuntu](https://ubuntu.com/download/alternative-downloads#bit-torrent) and tried to open it in a file editor, you'll be hard pressed to call this readable. The file is encoded in a format called `bencode`, the specification of which is available [here](https://wiki.theory.org/BitTorrentSpecification#Bencoding).

The TL;DR is that we can use it to represent basic types - e.g. a positive integer is represented as a stream starting with `i` and ending with `e`. So 123 would be encoded as `i123e`. Lists have a similar setup - with `l` being the start delimiter. So the list `[123,456]` would be represented as `li123ei456ee`. Lists can contain other lists too!

Byte strings (I guess that'd be `char` in C?) are a little different in that they start with a number representing the length, delimited by `:` - so "foo" would be encoded as `3:foo`.

Dictionaries are similar to lists, starting with a `d` (easy heh?). Keys must be sorted in byte order and must be byte strings - so the Python dict `{'foo': 123}` would be encoded as `d3:fooi123ee`.

# Approach

If you have ever used a stream-based parser like `StAX` for XML, or `PyYAML`, we'll be doing something somewhat similar. Take this list with a nested element for example:

```
[1, [2], 3] = li1eli2eei3ee
```

As we process the stream, the structure looks a little bit like a tree:

```
[
    1,
    [
        2
    ],
    3
]
```

When we encounter the first `[` we set the "node type" to a list, and recursively call our parser with the remaining of the stream. After reading `1` we look to see if we had a root note - we had and it's a list, so we append the value to it. We keep recursively call ourselves with the remaining bytes of the stream. In pseudo code, this looks a bit like:

```
parse(<holder>, 'li1eli2eei3ee')
    parse([, 'i1eli2eei3ee')
    parse([1, 'li2eei3ee')
        parse([1,[,'i2eei3ee')
        parse([1,[2,'ei3ee')
        parse([1,[2],'i3ee')
        parse([1,[2],3, 'e')
        parse([1,[2],3], '')
ret [1,[2],3]
```

# Interface, "data" holders

Here's the general interface - we only need 2 methods. One to add value as we see them, and one to return the contents.

{% highlight golang %}
type Holder interface {
	Add(value interface{})
	Obj() interface{}
}
{% endhighlight %}

Here are the basic type (`List`, `Dict` and `Value` - the latter is for scalars of all kinds):

{% highlight golang %}
type ListHolder struct {
	List []interface{}
}

type DictHolder struct {
	Dict map[string]interface{}
	// tracks the current key
	Key string
}

type ValueHolder struct {
	Val interface{}
}
{% endhighlight %}

Their implementation of the `Holder` interface is as follows:

{% highlight golang %}
// Add methods

func (c *ListHolder) Add(value interface{}) {
	c.List = append(c.List, value)
}

func (c *DictHolder) Add(value interface{}) {
	if c.Key == "" {
		c.Key = string(value.([]byte))
	} else {
		c.Dict[c.Key] = value
		// reset
		c.Key = ""
	}
}

func (c *ValueHolder) Add(value interface{}) {
	c.Val = value
}

// Obj methods

func (c *ListHolder) Obj() interface{} {
	return c.List
}

func (c *DictHolder) Obj() interface{} {
	return c.Dict
}

func (c *ValueHolder) Obj() interface{} {
	return c.Val
}
{% endhighlight %}

The only one worth a mention is the `DictHolder`. When we finish processing an element inside the `dict`, we need to know hwhether it was a key or a value - so we use `c.Key` internally as a toggle. If it's set, the next call to `Add` is for a value - and if not, it's the start of a key.

# Parsing

Now we almost ready to start parsing the stream! Let's start with some basic tests to ensure we're doing the right thing.

{% highlight golang %}
func TestBencodeRecursiveParser(t *testing.T) {
	r := bytes.NewReader([]byte("i42e"))
	ret := data.ParseBencoded2(r)
	if ret != 42 {
		t.Errorf("expected 42, got %v", ret)
	}
}

{% endhighlight %}


# Encoding

We're half-way there. We can parse data, let's make sure we can serialise it back. The beauty of this is that from a test perspective, `encode(parse(data))` is equivalent to the identity function! That is, this is just equal to `data`. A bit like decompressing a compressed file.

{% highlight golang %}
{% endhighlight %}

# Struct tags

I'm saddened to say the above was the fun part. 

{% highlight golang %}
{% endhighlight %}

# Taking it further
