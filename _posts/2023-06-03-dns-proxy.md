---
layout: post
title: dns-proxy-in-go
excerpt: "Inspect DNS requests and sinkhole accordingly"
categories: [coding]
tags: [howto,golang]
---

I recently picked up a copy of [Black Hat Go](https://nostarch.com/blackhatgo) which touched upon something I've been wanting to do for a while - namely a DNS proxy that logs DNS requests and sinkholes certain domains, particularly pertaining to adverts or tracking. Now a fair bunch can be done via Browser plugins but with e.g. a phone app, router, internet-enabled device, you're better off setting up your own DNS. I'm fully aware there's already stuff out there that does this but I've been meaning to get back into `golang` and this felt like a great opportunity.

We'll focus on functionality first before adding the bells and whilstles later.

# Transparent proxy

For this to be any use we'll first want to transparently relay our requests to a DNS server of our choice (e.g. Google's `8.8.8.8`). For this we'll use the excellent [dns](https://www.github.com/miekg/dns) package.

The POC looks like this:

{% highlight golang %}
package main

import (
	"github.com/miekg/dns"
	"log"
)

func main() {
	var serverAddr = "8.8.8.8:53"
	dns.HandleFunc(".", func(w dns.ResponseWriter, req *dns.Msg) {
		log.Printf("%+v\n",req)
		resp, err := dns.Exchange(req, serverAddr)
		if err != nil {
			dns.HandleFailed(w, req)
			return
		}
		if err := w.WriteMsg(resp); err != nil {
			dns.HandleFailed(w, req)
			return
		}

	})
	log.Fatal(dns.ListenAndServe(":53", "udp", nil))
}
{% endhighlight %}

`go run` the above, and let's use `dig` to query:

```
❯ dig +noall +answer facebook.com
facebook.com.           279     IN      A       157.240.13.35
❯ dig @localhost +noall +answer facebook.com
facebook.com.           275     IN      A       157.240.235.35
❯ dig @localhost +noall +answer facebook.com
facebook.com.           22      IN      A       157.240.15.35
```

There's some load-balancing going on here but we're looking at IPs in the same subnet so we must be doing something right.

# Sinkhole

Right now we're forwarding clients requests to a *real* DNS - but we also want the ability to sinkhole certain domains. Let's start by writing this as a function. Note that a single DNS request can contain many questions, so we need to check all.

{% highlight golang %}
func localproxy(w dns.ResponseWriter, req *dns.Msg) {
	var resp dns.Msg
	resp.SetReply(req)
	for _, q := range req.Question {
		log.Printf("sinkholing req for %s", q.Name)
		a := dns.A{
			Hdr: dns.RR_Header{
				Name:   q.Name,
				Rrtype: dns.TypeA,
				Class:  dns.ClassINET,
				Ttl:    60,
			},
			A: net.ParseIP("127.0.0.1").To4(),
		}
		resp.Answer = append(resp.Answer, &a)
	}
	w.WriteMsg(&resp)
}
{% endhighlight %}

The target IP could be anything but `localhost` has a nice ring to it.

Extracting the forwarding logic into its own `forward` `func`, we can rewrite `main` as:

{% highlight golang %}
func main() {

	dns.HandleFunc("facebook.com", forward)
	dns.HandleFunc("abc.facebook.com", localproxy)
	log.Fatal(dns.ListenAndServe(":53", "udp", nil))
}
{% endhighlight %}

Note that the order in which we define those `HandleFunc` will respect the domain hierarchy (as in the ordering doesn't matter - the most-specific match is tried first before bubbling up to the top-level domain).

# Config, hot reload and command-line flags

With the above we have the basic functionality down - but there's more we can do to make this user-friendly and packageable. At the very least we'll want to:
  - write to a file a list of all the domains requested that were proxied transparently (for review)
  - pass in the name of a file containing a list of sinkholed domains
  - make the above cmdline flags, as well as specifying which DNS to forward requests to

## List of sinkholed domains

The `dns` package has a `HandleRemove` method - meaning that as long as we keep track of what gets added we should able to remove them.

To get this going we'll need to kick off `dns.ListenAndServe` in its own `goroutine`, and ditto for our signal handlers (we have one for `Ctrl-C` essentially, and one for `SIGHUP` that triggers the reload):

{% highlight golang %}
    go func() {
		log.Fatal(dns.ListenAndServe(":53", "udp", nil))
	}()

	sigsStop := make(chan os.Signal, 1)
	signal.Notify(sigsStop, syscall.SIGINT, syscall.SIGTERM)
	sigHup := make(chan os.Signal, 1)
	signal.Notify(sigHup, syscall.SIGHUP)
	done := make(chan bool, 1)

	go func() {
        reload()
		for {
			<-sigHup
			reload()
		}
	}()

	go func() {
		<-sigsStop
		log.Printf("shutting down")
		done <- true
	}()

	<-done
{% endhighlight %}

where `reload`, for now, can be as simple as what we had before:

{% highlight golang %}
func reload() {
    log.Printf("reload called\n")
	dns.HandleFunc(".", forward)
	dns.HandleFunc("facebook.com", forward)
	dns.HandleFunc("abc.facebook.com", localproxy)
}
{% endhighlight %}

Let's make sure this works by sending `kill -HUP 72149` once it's up:

```
2023/06/02 21:00:21 PID: 72149
2023/06/02 21:00:21 reload called
2023/06/02 21:00:40 reload called
```

Let's now add the bit that reads from a file!

## Log

## Flags

For the final bells and whistles!

# Taking it further

As I was writing this, I realised that maybe it might make more sense to have this the other waya round - sinkhole *everything* and only allow-list what is really needed. This is "left as an exercise to the reader" (it should be a case of swapping the `forward` and `sinkhole` functions).

Also returning a dummy record for sinkholed domains isn't quite enough as the client will likely try to make a connection. We can spin up a local web server that returns... nothing. This will ensure the connection from the client gets closed quickly and doesn't hang around forever (or whatever timeout the client is set to).

{% highlight golang %}
{% endhighlight %}