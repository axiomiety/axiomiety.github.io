---
layout: post
title: go-bt-3
excerpt: "Write a BitTorrent client from scratch in Go: part 3"
categories: [coding]
tags: [howto,golang]
---

In [part 2]({% post_url 2024-09-01-go-bt-2 %}) we looked at the `.torrent` file format. In this post we will see how to leverage this to communicate with a tracker and obtain a list of peers - it's through those peers that we will eventually get the necessary blocks to reconstruct the original file(s).

We're building up from the [go-bt](https://github.com/axiomiety/go-bt) repository. Clone it if you want to follow along!

# Connecting to the tracker

A `.torrent` file contains an `announce` (or `announce-list` depending) key. This is where the tracker is hosted.

The role of the tracker is to maintain an updated list of peers and related statistics pertaining to the health of the torrent. For instance it should be able to tell you how many peers contain all the blocks (such peers are called seeds).

The tracker is essentially a (web) server - it receives queries, updates some internal state, and sends responses. There's a whole set of query parameters, a good chunk of which is optional. If the `announce` key is something like "http://foo.bar", a `GET` request to the tracker might look like:

```
curl -X GET 'https://torrent.ubuntu.com/announce?info_hash=A%E6%CDP%CC%ECU%CDW%04%C5%E3%D1v%E7%B5%93%17%A3%FB&peer_id=%FC%93%15%9A%3A%B0as%F2%91%A4-%7F%BE%3A%60%D2l74&port=6688&uploaded=0&downloaded=0&left=0'
d8:completei488e10:incompletei21e8:intervali1800e5:peersld2:ip23:2601:19b:c800:930::10087:peer id20:-TR3000-j43xqxgtg51v4:porti51413eed2:ip22:2001:14ba:ab01:c79b::17:peer 
<truncated>
```

## `info_hash`

The first thing we need to query a tracker is to calculate the digest of the `info` dict. Technically the output of a hashing function is called a digest, but in the spec this is known as the `info_hash` - so we'll reference it as such. Let's support getting this from a `BEInfo` struct:

{% highlight golang %}
func TestInfoHash(t *testing.T) {
	file, _ := os.Open("../bencode/testdata/files.torrent")
	defer file.Close()
	btorrent := bencode.ParseFromReader[data.BETorrent](file)
	rawDigest := torrent.CalculateInfoHash(&btorrent.Info)
	infoDigest := hex.EncodeToString(rawDigest[:])
	expectedDigest := "b6e355aa9e2a9b510cf67f0b4be76d9da36ddbbf"
	if infoDigest != expectedDigest {
		t.Errorf("expected %s, got %s", expectedDigest, infoDigest)
	}
}
{% endhighlight %}

Leveraging the ground work in part 1, it's dead easy. We're adding a conveninence function to generate this from a `BEInfo` struct but really it's all about having it as a bencoded map:

{% highlight golang %}
func CalculateInfoHash(info *data.BEInfo) [20]byte {
	return CalculateInfoHashFromInfoDict(bencode.ToDict(*info))
}

func CalculateInfoHashFromInfoDict(info map[string]any) [20]byte {
	var buf bytes.Buffer
	bencode.Encode(&buf, info)
	return sha1.Sum(buf.Bytes())
}
{% endhighlight %}

I also cross-referenced that with the one calculated by qBittorrent and it matches!

## `peerId`

This also a 20-bytes value. Some popular client use their own prefix which can allow us to identify which clients peers are running. For our purposes we can generate a random one for now though there's value in keeping the same peer ID (it reduces churn):

{% highlight golang %}
peerId := make([]byte, 20)
rand.Read(peerId)
{% endhighlight %}

## `port`

This lets other peers know which port they should connect to. Our IP address is available to the tracker from our original request (though it's possible to specify it - if say you're using a proxy). We won't go into NAT but suffice to say if you're behind a firewall you'll need to make sure this is redirected accordingly. This is usually a value in the `6881-6889` range.

## `uploaded,downloaded,left`

Those values can be used to help the tracker keep track of e.g. how many peers are seeds (they have all the blocks required) vs leeches (download is incomplete). For our purpose we can simply set those to 0.

## Byte string encoding

One thing that tripped me up originally is how we send those 20-bytes-long values to the tracker. Unfortunately we can't just add them as `url.Query` parameters directly - the encoding is... custom. Here's my implementation based on the spec (which makes liberal use of `fallthrough`):

{% highlight golang %}
	switch {
	case val == '.' || val == '-' || val == '_' || val == '~':
		fallthrough
	case '0' <= val && val <= '9':
		fallthrough
	case 'a' <= val && val <= 'z':
		fallthrough
	case 'A' <= val && val <= 'Z':
		return string(val)
	default:
		return fmt.Sprintf("%%%s", strings.ToUpper(hex.EncodeToString([]byte{val})))
	}
}
{% endhighlight %}




# The tracker's response

```
```

# Creating our own (basic) tracker service

If you wanted to manage file transfers on a fleet of machines on an internal network (say system updates), you might want to run your own tracker internally. Your torrents wouldn't be meaningful outside your own organisation.

Realistically though we only really need our tracker to do three things:
  - allow new peers to register themselve
  - evict peers that haven't sent a heartbeat in a given interval
  - provide a list of (active) peers to those that query the `announce` endpoint

{% highlight golang %}
{% endhighlight %}

# Taking it further

## Wait is a tracker always HTTP?

Not at all - in an effort to reduce traffic to and for trackers, a new [UDP tracker specification](https://web.archive.org/web/20170101194115/http://bittorrent.org/beps/bep_0015.html) exists. There are significant 

## What is this `compact` thing?

Some trackers accept a `compact=1` argument to the query string. 

```
/V/r/g/src ❯❯❯ curl -s -X GET 'https://torrent.ubuntu.com/announce?info_hash=A%E6%CDP%CC%ECU%CDW%04%C5%E3%D1v%E7%B5%93%17%A3%FB&peer_id=%FC%93%15%9A%3A%B0as%F2%91%A4-%7F%BE%3A%60%D2l74&port=6688&uploaded=0&downloaded=0&left=0&compact=1' | xxd
00000000: 6438 3a63 6f6d 706c 6574 6569 3335 3365  d8:completei353e
00000010: 3130 3a69 6e63 6f6d 706c 6574 6569 3133  10:incompletei13
00000020: 6538 3a69 6e74 6572 7661 6c69 3138 3030  e8:intervali1800
00000030: 6535 3a70 6565 7273 363a b97d be3b 1b03  e5:peers6:.}.;..
00000040: 65                                       e
```

Here the whole `peers` data structure has been replaced with a single `peers` string. A block of 6 bytes is used to represent the IP (using the first 4) and the port (the last 2). In the example above we have a single block: `b97d be3b 1b03`:

```
>>> 0xb9,0x7d,0xbe,0x3b,0x1b03
(185, 125, 190, 59, 6915)
```

Making the peer's IP `185.125.190.59` on port 6915.

