---
layout: post
title: go-bt-3
excerpt: "Write a BitTorrent client from scratch in Go: part 3"
categories: [coding]
tags: [howto,golang]
---

In [part 2]({% post_url 2024-09-01-go-bt-2 %}) we looked at the `.torrent` file format. In this post we will see how to leverage this to communicate with a tracker and obtain a list of peers - it's through those peers that we will eventually get the necessary blocks to reconstruct the original file(s).

We're building up from the [go-bt](https://github.com/axiomiety/go-bt) repository. Clone it if you want to follow along!

# Connecting to the tracker

A `.torrent` file contains an `announce` (or `announce-list` depending) key. This is where the tracker is hosted.

The role of the tracker is to maintain an updated list of peers and related statistics pertaining to the health of the torrent. For instance it should be able to tell you how many peers contain all the blocks (such peers are called seeds).

The tracker is essentially a web server - it receives queries, updates some internal state, and sends responses. There's a whole set of query parameters with a good chunk optional. If the `announce` key is something like "http://foo.bar", a `GET` request to the tracker might look like:

```
```

Let's focus on the necessary few.

## `info_hash`

The first thing we need to query a tracker is to calculate the digest of the `info` dict. Technically the output of a hashing function is called a digest, but in the spec this is known as the `info_hash` - so we'll reference it as such. Let's support getting this from a `BEInfo` struct:

{% highlight golang %}
func TestInfoHash(t *testing.T) {
	file, _ := os.Open("../bencode/testdata/files.torrent")
	defer file.Close()
	btorrent := bencode.ParseFromReader[data.BETorrent](file)
	rawDigest := torrent.CalculateInfoHash(&btorrent.Info)
	infoDigest := hex.EncodeToString(rawDigest[:])
	expectedDigest := "b6e355aa9e2a9b510cf67f0b4be76d9da36ddbbf"
	if infoDigest != expectedDigest {
		t.Errorf("expected %s, got %s", expectedDigest, infoDigest)
	}
}
{% endhighlight %}

Leveraging the ground work in part 1, it's dead easy. We're adding a conveninence function to generate this from a `BEInfo` struct but really it's all about having it as a bencoded map:

{% highlight golang %}
func CalculateInfoHash(info *data.BEInfo) [20]byte {
	return CalculateInfoHashFromInfoDict(bencode.ToDict(*info))
}

func CalculateInfoHashFromInfoDict(info map[string]any) [20]byte {
	var buf bytes.Buffer
	bencode.Encode(&buf, info)
	return sha1.Sum(buf.Bytes())
}
{% endhighlight %}

I also cross-referenced that with the one calculated by qBittorrent and it matches!

## `GET`


# Creating our own (basic) tracker service

If it sounds odd to host your own tracker service, 

{% highlight golang %}
type Holder interface {
	Add(value any)
	Obj() any
}
{% endhighlight %}

# Taking it further